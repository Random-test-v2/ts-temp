/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { SDKValidationError } from "./errors/sdk-validation-error.js";
import {
  TypesAlertSettings,
  TypesAlertSettings$inboundSchema,
} from "./types-alert-settings.js";
import {
  TypesAlertState,
  TypesAlertState$inboundSchema,
} from "./types-alert-state.js";
import {
  TypesAutoTopup,
  TypesAutoTopup$inboundSchema,
} from "./types-auto-topup.js";
import {
  TypesCreditBreakdown,
  TypesCreditBreakdown$inboundSchema,
} from "./types-credit-breakdown.js";
import { TypesStatus, TypesStatus$inboundSchema } from "./types-status.js";
import {
  TypesWalletConfig,
  TypesWalletConfig$inboundSchema,
} from "./types-wallet-config.js";
import {
  TypesWalletStatus,
  TypesWalletStatus$inboundSchema,
} from "./types-wallet-status.js";
import {
  TypesWalletType,
  TypesWalletType$inboundSchema,
} from "./types-wallet-type.js";

export type DtoWalletBalanceResponse = {
  alertSettings?: TypesAlertSettings | undefined;
  alertState?: TypesAlertState | undefined;
  autoTopup?: TypesAutoTopup | undefined;
  balance?: string | undefined;
  balanceUpdatedAt?: string | undefined;
  config?: TypesWalletConfig | undefined;
  /**
   * amount in the currency =  number of credits * conversion_rate
   *
   * @remarks
   * ex if conversion_rate is 1, then 1 USD = 1 credit
   * ex if conversion_rate is 2, then 1 USD = 0.5 credits
   * ex if conversion_rate is 0.5, then 1 USD = 2 credits
   */
  conversionRate?: string | undefined;
  createdAt?: string | undefined;
  createdBy?: string | undefined;
  creditBalance?: string | undefined;
  creditsAvailableBreakdown?: TypesCreditBreakdown | undefined;
  currency?: string | undefined;
  currentPeriodUsage?: string | undefined;
  customerId?: string | undefined;
  description?: string | undefined;
  environmentId?: string | undefined;
  id?: string | undefined;
  metadata?: { [k: string]: string } | undefined;
  name?: string | undefined;
  realTimeBalance?: string | undefined;
  realTimeCreditBalance?: string | undefined;
  status?: TypesStatus | undefined;
  tenantId?: string | undefined;
  /**
   * topup_conversion_rate is the conversion rate for the topup to the currency
   *
   * @remarks
   * ex if topup_conversion_rate is 1, then 1 USD = 1 credit
   * ex if topup_conversion_rate is 2, then 1 USD = 0.5 credits
   * ex if topup_conversion_rate is 0.5, then 1 USD = 2 credits
   */
  topupConversionRate?: string | undefined;
  unpaidInvoicesAmount?: string | undefined;
  updatedAt?: string | undefined;
  updatedBy?: string | undefined;
  walletStatus?: TypesWalletStatus | undefined;
  walletType?: TypesWalletType | undefined;
};

/** @internal */
export const DtoWalletBalanceResponse$inboundSchema: z.ZodMiniType<
  DtoWalletBalanceResponse,
  unknown
> = z.pipe(
  z.object({
    alert_settings: types.optional(TypesAlertSettings$inboundSchema),
    alert_state: types.optional(TypesAlertState$inboundSchema),
    auto_topup: types.optional(TypesAutoTopup$inboundSchema),
    balance: types.optional(types.string()),
    balance_updated_at: types.optional(types.string()),
    config: types.optional(TypesWalletConfig$inboundSchema),
    conversion_rate: types.optional(types.string()),
    created_at: types.optional(types.string()),
    created_by: types.optional(types.string()),
    credit_balance: types.optional(types.string()),
    credits_available_breakdown: types.optional(
      TypesCreditBreakdown$inboundSchema,
    ),
    currency: types.optional(types.string()),
    current_period_usage: types.optional(types.string()),
    customer_id: types.optional(types.string()),
    description: types.optional(types.string()),
    environment_id: types.optional(types.string()),
    id: types.optional(types.string()),
    metadata: types.optional(z.record(z.string(), types.string())),
    name: types.optional(types.string()),
    real_time_balance: types.optional(types.string()),
    real_time_credit_balance: types.optional(types.string()),
    status: types.optional(TypesStatus$inboundSchema),
    tenant_id: types.optional(types.string()),
    topup_conversion_rate: types.optional(types.string()),
    unpaid_invoices_amount: types.optional(types.string()),
    updated_at: types.optional(types.string()),
    updated_by: types.optional(types.string()),
    wallet_status: types.optional(TypesWalletStatus$inboundSchema),
    wallet_type: types.optional(TypesWalletType$inboundSchema),
  }),
  z.transform((v) => {
    return remap$(v, {
      "alert_settings": "alertSettings",
      "alert_state": "alertState",
      "auto_topup": "autoTopup",
      "balance_updated_at": "balanceUpdatedAt",
      "conversion_rate": "conversionRate",
      "created_at": "createdAt",
      "created_by": "createdBy",
      "credit_balance": "creditBalance",
      "credits_available_breakdown": "creditsAvailableBreakdown",
      "current_period_usage": "currentPeriodUsage",
      "customer_id": "customerId",
      "environment_id": "environmentId",
      "real_time_balance": "realTimeBalance",
      "real_time_credit_balance": "realTimeCreditBalance",
      "tenant_id": "tenantId",
      "topup_conversion_rate": "topupConversionRate",
      "unpaid_invoices_amount": "unpaidInvoicesAmount",
      "updated_at": "updatedAt",
      "updated_by": "updatedBy",
      "wallet_status": "walletStatus",
      "wallet_type": "walletType",
    });
  }),
);

export function dtoWalletBalanceResponseFromJSON(
  jsonString: string,
): SafeParseResult<DtoWalletBalanceResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DtoWalletBalanceResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DtoWalletBalanceResponse' from JSON`,
  );
}
